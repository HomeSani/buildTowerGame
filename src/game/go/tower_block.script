function init(self)
	self.is_stand = false
	self.position = go.get_position()
	self.velocity = vmath.vector3(0, 0, 0)

	self.gravity = 0

	self.stand_offset = 90
end

function update(self, dt)
	local gravity = vmath.vector3(0, self.gravity, 0)

	if not self.is_stand then
		self.velocity = self.velocity + gravity
		go.set_position(go.get_position() + self.velocity * dt)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("start_falling") then
		self.gravity = -5
	end

	-- check stand
	if message_id == hash("collision_response") and self.is_stand == false then
		self.is_stand = true
		self.gravity = 0
		self.velocity = go.get_position()

		msg.post("/game_manager#game_manager", "tower_is_stand")

		if not(message.other_id == hash("/roud")) then
			local block_pos = go.get_position()
			local last_block_pos = go.get_position(message.other_id)

			-- if block position out of stand zone

			-- left limit
			if block_pos.x < last_block_pos.x - self.stand_offset then
				go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 90, go.EASING_LINEAR, 0.6)
				go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(block_pos.x - self.stand_offset/2, block_pos.y+self.stand_offset/2, 0), go.EASING_INBACK, 0.4)
				go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, -1000, go.EASING_LINEAR, 3, 0.3)
			end
			-- right limit
			if block_pos.x > last_block_pos.x + self.stand_offset then
				go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, -90, go.EASING_LINEAR, 0.6)
				go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(block_pos.x + self.stand_offset/2, block_pos.y+self.stand_offset/2, 0), go.EASING_INBACK, 0.4)
				go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, -1000, go.EASING_LINEAR, 3, 0.3)
			end
		end
	end
end